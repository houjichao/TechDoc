今天我们要讲的是设计模式中三种模式（创建型模式、行为型模式、结构型模式）中的**创建型模式中的建造者模式**，也可以叫 **Builder模式**。

与其他的创建型模式比如工厂模式一样都是用来服务相同的目标，但是他们的作用场景不一样，实现方式不一样而已，但最终的目的都是一个：就是为了让我们写出结构严谨，易懂且易扩展的高质量代码。

## 建造者模式

什么叫建造者？他的应用场景又是什么呢？

> 当我们需要实列化一个复杂的类，以得到不同结构类型和不同的内部状态的对象时，我们可以用不同的类对它们的实列化操作逻辑分别进行封装，这些类我们就称之为建造者。
>
> 当我们需要来之同一个类，但是要就有不同结构对象时，就可以通过构造另一个建造者来进行实列化。
>
> ----------以上定义来自《设计模式之美》。

为了加深理解我们再来一个流程图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80a38c963744f869e487c9a74d375d1~tplv-k3u1fbpfcp-zoom-1.image)

从图中我们主以看出建造者主要分为4种角色：

> - Product(产品类) :我们具体需要生成的类对象
> - Builder(抽象建造者类)：为我们需要生成的类对象，构建不同的模块属性，即：公开构建产品类的属性，隐藏产品类的其他功能
> - ConcreteBuilder(具体建造者类)：实现我们要生成的类对象
> - Director(导演类)：确定构建我们的类对象具体有哪些模块属性，在实际应用中可以不需要这个角色，直接通过client处理

### 举例

在电商中有多种不同类型的商品 **普通实物商品**，**电子卡券商品**，**虚拟视频学习商品** 等多种不同的商品，他们都是商品但是他们的属性却不一样，电子卡券：独有券码，学习视频：独有视频链接等。

那我们要怎么实现这种这种创建商品呢？

我们先看下最普通的创建方式：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0a508050824932bb7f8db64e69c353~tplv-k3u1fbpfcp-zoom-1.image)

我们先创建一个基础商品Item类：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6a86b0d17594cbd945298f8e1d17ca6~tplv-k3u1fbpfcp-zoom-1.image)

这里我们可以看到根据请求类型，也可以完全创建出我们想要的类型商品，但是一个商品属性不可能只有这么一点属性，那以后扩展更多呢？那这个代码我们看上去就会很臃肿，也不好维护。

接下来我们就看下建造者模式怎么去实现：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327a8e0f23f1414ca89d09195abe60be~tplv-k3u1fbpfcp-zoom-1.image)

第一步：创建我们的抽象建造者类。这里面我们看下有三个抽象方法，来确定不同的商品类型，我们调用不同的方法，达到解偶的思想

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6752936cca24c818da0b5ef8e93afc0~tplv-k3u1fbpfcp-zoom-1.image)

第二步：创建具体建造者类。对**抽象建造者类**的抽象方法进行实现赋值，达到我们所需要的结果。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d96722b61984ea4b54a71dc40ee6977~tplv-k3u1fbpfcp-zoom-1.image)

第三步：创建我们的导演类。指导我们怎么去创建对象，这个我们是可以简化的，视具体使用场景确定吧！

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1237cb6477427896b1365c9f9f762b~tplv-k3u1fbpfcp-zoom-1.image)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72a82823e6a4f62800e04154b0dcc60~tplv-k3u1fbpfcp-zoom-1.image)

最后就是看我们的测试结果了。在省略导演类的时候其实我们也完全可以的构建出我们想要的结果，因为我这写的是测试demo所以没有写传参，这个大家可以根据自己的实际应用场景去做改造。

与普通的写法相比**建造者模式**的写法使的这个代码可读性高，而且易扩展，不同类型的商品达到了解耦合的效果。

### 举例二：

假设我们现在有另外的一种场景，我们复制一个商品时，当没有填写库存时我们默认是0，当用户填写了时我们库存数量不能大于999999999。

那我们要怎么去实现呢？

> PS：商品复制这个功能在电商领域是很普通的一个操作，对用户来说简化操作成本，提升用户体检。技术服务于业务，业务决定公司的长远利益

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5acabef318b403fb86d4a0b86bbc724~tplv-k3u1fbpfcp-zoom-1.image)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbc58cb53c274a508251a94c86437ac7~tplv-k3u1fbpfcp-zoom-1.image)

我们在内部创建了一个ItemBuilder，来处理我们的校验逻辑。当然我们使用普通的get，set方式其实也是可以实现的。

看到这里可能有人会问这个与我们使用get或者set方法又有什么区别呢？

解释：主要是为了解决我们的赋值处于一种无效状态

> 无效状态指的是对象属性之间存在依赖关系，合法校验等，如果使用set方式会导致这种关系和校验得不到验证，所有可能会存在无效的状态，即A、B两个属性必须同时设置，缺一不可，然后set方法可能导致遗漏等

## 总结

以上就是我要跟大家了解的建造者模式，其实我还是想跟大家分享这种思想吧，像第二个列子大家也可以用于写配置文件(**比如我们的链接池，里面很多必填或者不必填参数，同时也可以避免在因为属性值过多而写构造方法时产生不好维护，不雅观的现象**)等，因为我一直在电商公司工作，所以我举的列子都是以电商为主。

只有我们了解了每种设计模式解决了什么问题，我们才知道哪种场景用什么模式或者多种设计模式进行组合，避免产生因强行使用设计模式，反而使得代码更加的不好维护了。I


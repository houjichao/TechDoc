并行，指的是**在同一时刻**多个任务同时执行。

并发，指的是**在同一时间段**多个任务交替执行。

当然，并行的执行速度更快，但并行也依赖硬件设置，因为它依赖硬件CPU是多核的场景。并发则不受限制。

### parallelStream

想要把串行流转换为并行流很简单，只需要将`stream`修改为`parallelStream`，其它操作不变。

```java
public void parallel(List<Student> students) {
    students.parallelStream()
            .map(Student::getStudentNumber)
            .collect(Collectors.toList());
}
```

Stream流的并行化操作，是一种**数据并行化**，流本身就擅长对数据进行运算。

当然并不是将代码里所有的串行流改为并行流就万事大吉性能翻倍了，数据少了不行，CPU核数不够也不行。所以要想真正能提高性能，还要针对实际请做测试才能得出结论。

我测试了9个学生、90个学生、9000个学生、90000个学生后，三者的性能表现如下图所示：

| 操作         | 9个学生 | 90个学生 | 900个学生 | 9000个学生 | 90000个学生 | 900000个学生 |
| :----------- | :------ | :------- | :-------- | :--------- | :---------- | :----------- |
| for循环      | 0ms     | 0ms      | 2ms       | 8ms        | 41ms        | 343ms        |
| 串行化Stream | 61ms    | 1ms      | 2ms       | 4ms        | 27ms        | 789ms        |
| 并行化Stream | 4ms     | 0ms      | 4ms       | 3ms        | 88ms        | 358ms        |

所以单单从数据量上可以看出：

for循环的性能随着数据量的增加性能也越来越差。

串行化流则在数据量小的情况下性能差，数据量中、大的时候性能略高于for循环，但当数据量特别大时，性能也变得越差。

并行化流受CPU核数的影响，在本机2核下，在数据量小的情况下性能略高于串行化流，略低于for循环，在数据量中的情况下差不多，在数据量比较大时性能最差，但当数据量特别大时，性能也变得更好。

如果想要使用`parallelStream`想提高性能，一定要根据实际情况做好测试，因为**并行化的流性能不一定比串行化流性能高**。



### 总结

1. stream实现集合的操作代码量少，简洁，for代码量大

2.  stream实现集合的操作可以是并行的(多线程)，for是串行的
3. stream在数据量大的情况下效率高，for在数据量小的情况下效率高，不过这只针对合理的数据量级



[并行串行对比](https://www.jianshu.com/p/933547a77fdf)




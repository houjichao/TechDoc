# Synchronized优化

`Jdk 1.5`以后对`Synchronized`关键字做了各种的优化，经过优化后`Synchronized`已经变得原来越快了，这也是为什么官方建议使用`Synchronized`的原因，具体的优化点如下。

- **锁粗化**
- **锁消除**
- **锁升级**

## 锁粗化

**互斥的临界区**范围应该尽可能小，这样做的目的是为了使同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。

但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，**锁粗化**就是将「**多个连续的加锁、解锁操作连接在一起**」，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738f2754e4454ada931525c5fc395e0c~tplv-k3u1fbpfcp-zoom-1.image)

`J V M`会检测到一连串的操作都对同一个对象加锁（`for`循环`10000`次执行`j++`，没有锁粗化就要进行`10000`次加锁/解锁），此时`J V M`就会将加锁的范围粗化到这一连串操作的外部（比如`for`循环体外），使得这一连串操作只需要加一次锁即可。

## 锁消除

`Java`虚拟机在`JIT`编译时(**可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译**)，通过对运行上下文的扫描，经过逃逸分析（**对象在函数中被使用，也可能被外部函数所引用，称为函数逃逸**），去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的时间消耗。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715d3128c57440d3a3d2d9b4c6c0c895~tplv-k3u1fbpfcp-zoom-1.image)

代码中使用`Object`作为锁，但是`Object`对象的生命周期只在`incrFour()`函数中，并不会被其他线程所访问到，所以在`J I T`编译阶段就会被优化掉（**此处的`Object`属于没有逃逸的对象**）。

## 锁升级

`Java`中每个对象都拥有对象头，对象头由`Mark World` 、指向类的指针、以及数组长度三部分组成，本文，我们只需要关心`Mark World` 即可，` Mark World`  记录了对象的`HashCode`、分代年龄和锁标志位信息。

**Mark World简化结构**

| 锁状态   | 存储内容                                                | 锁标记 |
| -------- | ------------------------------------------------------- | ------ |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01     |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01     |
| 轻量级锁 | 指向栈中锁记录的指针                                    | 00     |
| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10     |

读者们只需知道，锁的升级变化，体现在锁对象的对象头`Mark World`部分，也就是说`Mark World`的内容会随着锁升级而改变。

`Java1.5`以后为了减少获取锁和释放锁带来的性能消耗，引入了**偏向锁**和**轻量级锁**，`Synchronized`的升级顺序是 「**无锁-->偏向锁-->轻量级锁-->重量级锁，只会升级不会降级**」

### 偏向锁

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁，其目标就是在只有一个线程执行同步代码块时，降低获取锁带来的消耗，提高性能（**可以通过J V M参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态**）。

线程执行同步代码或方法前，线程只需要判断对象头的`Mark Word`中线程`ID`与当前线程`ID`是否一致，如果一致直接执行同步代码或方法，具体流程如下

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73c10eeb5c3d45c2b5c9722b2d055a07~tplv-k3u1fbpfcp-zoom-1.image)

- 无锁状态，存储内容「是否为偏向锁（`0`）」，锁标识位`01`
  - **`CAS`设置当前线程ID到`Mark Word`存储内容中**
  - ***\*是否为偏向锁\**`0` => 是否为偏向锁`1`**
  - **执行同步代码或方法**
- 偏向锁状态，存储内容「是否为偏向锁（`1`）、线程ID」，锁标识位`01`
  - **对比线程`ID`是否一致，如果一致执行同步代码或方法，否则进入下面的流程**
  - **如果不一致，`CAS`将`Mark Word`的线程`ID`设置为当前线程`ID`，设置成功，执行同步代码或方法，否则进入下面的流程**
  - **`CAS`设置失败，证明存在多线程竞争情况，触发撤销偏向锁，当到达全局安全点，偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后在安全点的位置恢复继续往下执行。**

### 轻量级锁

轻量级锁考虑的是竞争锁对象的线程不多，持有锁时间也不长的场景。因为阻塞线程需要`C P  U`从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失，所以干脆不阻塞这个线程，让它自旋一段时间等待锁释放。

当前线程持有的锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 轻量级锁的获取主要有两种情况：① 当关闭偏向锁功能时；② 多个线程竞争偏向锁导致偏向锁升级为轻量级锁。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96e810c1f4a145ed8e6c8cb7d4edd008~tplv-k3u1fbpfcp-zoom-1.image)

- 无锁状态，存储内容「是否为偏向锁（`0`）」，锁标识位`01`
  - **关闭偏向锁功能时**
  - **`CAS`设置当前线程栈中锁记录的指针到`Mark Word`存储内容**
  - **锁标识位设置为`00`**
  - **执行同步代码或方法**
  - **释放锁时，还原来`Mark Word`内容**
- 轻量级锁状态，存储内容「线程栈中锁记录的指针」，锁标识位`00`（存储内容的线程是指"持有轻量级锁的线程"）
  - **`CAS`设置当前线程栈中锁记录的指针到`Mark Word`存储内容，设置成功获取轻量级锁，执行同步块代码或方法，否则执行下面的逻辑**
  - **设置失败，证明多线程存在一定竞争，线程自旋上一步的操作，自旋一定次数后还是失败，轻量级锁升级为重量级锁**
  - **`Mark Word`存储内容替换成重量级锁指针，锁标记位`10`**

### 重量级锁

轻量级锁膨胀之后，就升级为重量级锁，重量级锁是依赖操作系统的`MutexLock`（**互斥锁**）来实现的，需要从用户态转到内核态，这个成本非常高，这就是为什么`Java1.6`之前`Synchronized`效率低的原因。

升级为重量级锁时，锁标志位的状态值变为`10`，此时`Mark Word`中存储内容的是重量级锁的指针，等待锁的线程都会进入阻塞状态，下面是简化版的锁升级过程。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dd128a797444c6db4487a6fc5fccb04~tplv-k3u1fbpfcp-zoom-1.image)





### 补充：

#### 什么是自旋

我们了解什么叫自旋？“自旋”可以理解为“自我旋转”，这里的“旋转”指“循环”，比如 while 循环或者 for 循环。“自旋”就是自己在这里不停地循环，直到目标达成。而不像普通的锁那样，如果获取不到锁就进入阻塞。

#### 对比自旋和非自旋的获取锁的流程

我们用这样一张流程图来对比一下自旋锁和非自旋锁的获取锁的过程。

![自旋和非自旋对比](https://img-blog.csdnimg.cn/20201024150108209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E5MDQzNjQ5MDg=,size_16,color_FFFFFF,t_70#pic_center)

我们来看自旋锁，它并不会放弃 CPU 时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。

我们再来看下非自旋锁，非自旋锁和自旋锁是完全不一样的，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。

可以看出，非自旋锁和自旋锁最大的区别，就是如果它遇到拿不到锁的情况，它会把线程阻塞，直到被唤醒。而自旋锁会不停地尝试。那么，自旋锁这样不停尝试的好处是什么呢？


#### 自旋锁的好处

阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。

在很多场景下，可能我们的同步代码块的内容并不多，所以需要的执行时间也很短，如果我们仅仅为了这点时间就去切换线程状态，那么其实不如让线程不切换状态，而是让它自旋地尝试获取锁，等待其他线程释放锁，有时我只需要稍等一下，就可以避免上下文切换等开销，提高了效率。

用一句话总结自旋锁的好处，那就是自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。

#### 缺点

那么自旋锁有没有缺点呢？其实自旋锁是有缺点的。它最大的缺点就在于虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。

#### 适用场景

所以我们就要看一下自旋锁的适用场景。首先，自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。

可是**如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁**，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。
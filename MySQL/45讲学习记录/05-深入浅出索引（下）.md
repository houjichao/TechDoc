#### 覆盖索引：

在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。<strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong>

#### 索引的创建：

1. 在建立联合索引的时候，如何安排索引内的字段顺序。：这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong>



#### 索引下推

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。





上期的问题是，通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理。

在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。这道题目，我给你的“参考答案”是：重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。





本期期的问题是关于对联合主键索引和InnoDB索引组织表的理解。

```
CREATE TABLE `geek` (
	`a` INT ( 11 ) NOT NULL,
	`b` INT ( 11 ) NOT NULL,
	`c` INT ( 11 ) NOT NULL,
	`d` INT ( 11 ) NOT NULL,
	PRIMARY KEY ( `a`, `b` ),
	KEY `c` ( `c` ),
	KEY `ca` ( `c`, `a` ),
  KEY `cb` ( `c`, `b` ) 
) ENGINE = INNODB;
```

select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;

| a    | b    | c    | d    |
| ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | d    |
| 1    | 3    | 2    | d    |
| 1    | 4    | 3    | d    |
| 2    | 1    | 3    | d    |
| 2    | 2    | 2    | d    |
| 2    | 3    | 4    | d    |

主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。

索引 ca 的组织是先按c排序，再按a排序，同时记录主键

这个跟索引c的数据是一模一样的。

索引 cb 的组织是先按c排序，在按b排序，同时记录主键

所以，结论是ca可以去掉，cb需要保留。